import os

import matplotlib.pyplot as plt
import numpy as np
import torch
from scipy import ndimage
from skimage import io

MIN_PIXEL_COUNT = 10000
MAX_PIXEL_COUNT = 30000


def filter_region(image):
    """
    Count the number of pixels in the segmentation and return True if
    the count is within the specified minimum and maximum bounds.
    """
    pixel_count = np.sum(image)
    if MIN_PIXEL_COUNT <= pixel_count <= MAX_PIXEL_COUNT:
        print(pixel_count)
        return True


def a3_function(points):
    """
    Calculates the angle between 3 points in a point cloud based
    on the files generated by the 2D models, over a set of random points.
    """

    # Sample indices for random triples
    n = len(points)
    indices = np.random.default_rng(42).choice(n, size=(5000, 3))

    # Calculate angles
    v1 = points[indices[:, 0]]
    v2 = points[indices[:, 1]]
    v3 = points[indices[:, 2]]
    vectors1 = v1 - v2
    vectors2 = v3 - v2

    dot_products = np.sum(vectors1 * vectors2, axis=-1)

    # Normalize vectors
    norms1 = np.linalg.norm(vectors1, axis=-1)
    norms2 = np.linalg.norm(vectors2, axis=-1)

    # Deals with any invalid values
    with np.errstate(invalid="ignore"):
        angles = np.arccos(dot_products / (norms1 * norms2))

    # remove nans from invalid angles
    angles = np.rad2deg(angles)
    angles = angles[~np.isnan(angles)]

    return angles


def d2_function(points):
    """
    Calculates the distances between pairs of points in a point cloud based
    on a sample set of 2 points per element.
    """

    # Sample indices for random pairs
    n = len(points)
    indices = np.random.default_rng(42).choice(n, size=(5000, 2))

    # Get the points
    p1 = points[indices[:, 0]]
    p2 = points[indices[:, 1]]

    # Calculate the vector differences
    vectors = p1 - p2

    # Calculate the Euclidean distances
    distances = np.linalg.norm(vectors, axis=-1)

    return distances


def process_image(image, unique_colors):
    angles_list = []
    colors_list = []  # Keep track of the colors that were processed
    segmentation_number = 0  # Counter for the valid segmentations

    # Process each unique color
    for i, color in enumerate(unique_colors):
        # Create a binary image where the current color is set to 1 and others to 0
        region = np.all(image == color.astype(int), axis=-1).astype(int)

        if filter_region(region):
            # plt.imshow(region, cmap="gray")
            # plt.axis("off")
            # plt.savefig(
            #     f"test/test-segmentation-{segmentation_number}.png", bbox_inches="tight"
            # )  # Use the segmentation counter
            # plt.close()

            points = np.column_stack(np.where(region > 0))
            angles = d2_function(points)
            angles_list.append(angles)
            colors_list.append(
                (segmentation_number, color)
            )  # Append the segmentation number and color
            segmentation_number += 1  # Increment the counter for valid segmentations

    return angles_list, colors_list


def plot_histogram(angles_list, colors_list, num_bins=20):
    if not os.path.exists("plots"):
        os.makedirs("plots")

    # Iterate through the angles list
    for (segmentation_number, color), angles in zip(colors_list, angles_list):
        # Calculate the histogram and bins
        hist, bins = np.histogram(angles, bins=num_bins, density=True)

        # Calculate bin centers
        bin_centers = (bins[:-1] + bins[1:]) / 2

        # Convert the color from integer to float values (in the range of 0-1)
        color = color / 255

        # Plot the bin centers against the histogram values with the corresponding color
        plt.plot(
            bin_centers, hist, label=f"Segmentation {segmentation_number}", color=color
        )

    # Set labels, title, and legend
    plt.xlabel("Angles")
    plt.ylabel("Density")
    plt.title("Angle distribution for different segmentations")
    plt.legend()

    # Save the plot
    plt.savefig(f"output/d2-{IMAGENAME}.png")
    plt.close()


def get_unique_colors(image):
    unique_colors = np.unique(image.reshape(-1, image.shape[2]), axis=0)
    return unique_colors


def main():
    image_path = "output/VAN001_09-25-17.png"
    image = io.imread(image_path)
    unique_colors = get_unique_colors(image)

    print(f"Unique colors found in the image: {len(unique_colors)}")

    # Process the image and plot the histogram
    angles_list, colors_list = process_image(image, unique_colors)
    plot_histogram(angles_list, colors_list)


if __name__ == "__main__":
    main()
